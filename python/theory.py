"""
форматирование
Именованные аргументы

модули
создание пакетов
Модуль random. 
кортежи

ссылки
множества
стек
очередь
deque
Деструктуризация и оператор упаковки
Создание новых списков и оператор распаковки


Детерминированность. 
Стандартная библиотека. 
Свойства и методы. 
Цепочка методов. 
Определение функций. 
Возврат значений. 
Параметры функций. 
Необязательные параметры функций.
Именованные аргументы. 
Агрегация данных


Концепция списков.
Создание списков и добавление элементов.
Ссылки. Ссылки и изменяемость. 
Модификация списков поэлементно. 
Срезы. 
Итераторы.
Работа с REPL. 
Модули distutils, Setuptools, pip. 
Установка pip.
Инструмент pip и альтернативные источники пакетов\.
Виртуальные окружения. Cкрипты. 
Запускаемые модули и пакеты. 
Доступный инструментарий для работы с Python-проектами.
Начало работы с Poetry. 
Poetry и управление зависимостями.
Poetry и скрипты. 
Сборка дистрибутива пакета с помощью Poetry.
Линтинг.
Бэкенд на Python. 
Протокол HTTP. 
Микрофреймворки. 
Шаблонизация. 
СУБД. 
ORM. 
MVC. 
Fullstack-фреймворки. 
Тесты. 
Коллекции. 
Изменение данных в словаре.
Инициализация новых значений и defaultdicts. 
Множества. 
Изменение множеств. 
Операции над множествами. 
Методы объектов множеств. 
Хеш-таблицы. 
Позиционные аргументы. 
Именованные аргументы.
Больше об именованных аргументах. 
Операторы упаковки и распаковки. 
Функции высшего порядка. 
Знакомство с map, filter и reduce. 
Чистые функции. 
Замыкания. 
Анонимные функции. 
Декораторы. 
Больше о декораторах. 
Рекурсия. 
Цели тестирования. 
Утверждения. 
Фреймворк Pytest. 
Модульные тесты. 
Подготовка данных.
Плохие и хорошие практики тестирования. 
Тестирование через документацию. 
Покрытие кода тестами.
Разработка через тестирование. 
Непрерывная интеграция.
Онтология. 
Точки на координатной плоскости. 
Семантика списков и словарей. 
Создание абстракции. 
Интерфейсы. 
Уровневое проектирование. 
Инварианты.
Определения. 
Виртуальная файловая система. 
Манипуляции с виртуальной файловой системой. 
Обход дерева. 
Агрегация.
Аккумулятор
Концепции ООП. 
Классы, пространства имен, атрибуты. 
Объекты-одиночки и глобальные переменные. 
Инстанцирование классов и экземпляры. 
Методы. 
Инициализация и протоколы. 
Свойства. 
Наследование. 
Исключения. 
Шаблоны Проектирования. 
Конфигурация. 
Изменяемая конфигурация. 
Объекты-сущности, Объекты-значения и внедренные объекты.
Fluent Interface. 
Сборщики (Builders). 
Пишем код правильно
Представление символов и метасимвол.
Символьные классы. 
Позиция внутри строки. 
Альтернатива. 
Квантификация. 
Жадность. 
Группировка и обратная связь.
Модификаторы. 
Просмотр вперед и назад. 
Поиск по условию. Флаги
Архитектура Веба. 
Веб-сервер. 
Встроенный веб-сервер. 
Flask. 
Обработчики запросов.
HTTP Сессия (запрос и ответ). 
Динамические маршруты. 
Шаблонизатор. 
Наследование шаблонов.
Безопасность. 
Поисковые формы.
Персистентность. 
Модифицирующие формы. 
Именованные маршруты. 
CRUD: Создание. 
CRUD: Обновление. 
CRUD: Удаление. M
odel-View-Controller (MVC). 
Cookies. 
Сессия. 
Деплой
Тестирование ошибок. 
Фикстуры. 
Побочные эффекты. 
Тестирование кода, взаимодействующего с файлами. 
Инверсия зависимостей. 
Тестирование HTTP-запросов.
Манкипатчинг. 
Мокинг
Параметрический полиморфизм. 
Диспетчеризация по ключу (данные). 
Диспетчеризация по ключу (функции). 
Диспетчеризация по имени файла. 
Полиморфизм (утиная типизация). 
Null Object Pattern. 
Код, который убивает полиморфизм. 
Инверсия зависимостей. 
Стратегия (Паттерн). 
Динамическая диспетчеризация. 
Фабрика (Паттерн). 
Декоратор (Паттерн).
Шаблоны проектирования (Паттерны). 
Объектная композиция. 
Состояние (Паттерн). 
Множественное наследование и миксины.
Наследование. 
Модификаторы доступа. 
Позднее связывание. 
Шаблонный метод. 
Переопределение методов. 
Принцип подстановки Лисков. 
Исключения. 
Динамическая диспетчеризация. 
Абстрактные классы. 
Позднее статическое связывание. 
Метаклассы. 
Композиция вместо наследования. 
Функциональный и процедурный подход
Генераторы списков
Генераторы множеств и словарей
Генераторные выражения
Функции-генераторы
Открытие и закрытие файлов
Запись и чтение
Построчные чтение и запись
Менеджеры контекста
 """
# однострочный

#print("функция для печати")
#типы данных
"""
int
float
str
bool

list
tuple
dict


Множетсва. По плану курса их нет. Уникальные значения
set
frozenset
"""

number = 123
float1 = 123.1

"""
len() длина 
abs() модуль
max()
min()
sum()

chr() символ по юникод коду
hex() 16x

int()
str()
float()
bool()
list()
"""
"""str1 = '123'
str2 = "123"
print(len(str1))
print(abs(-5))
print(max(1, 2, 3, 4))
print(min(1, 2, 3, 4))"""
"""print(type(number)) # type - посмотреть тип данных
print(type(float1))
print(type(str1))
print(type(inp))
print(inp + 1)
print(1)"""
#операции
"""
+
-
*
/
// - целосчиленное деление
%
** - степень
"""
"""print(1 + 2, str2, 8 % 2 == 0, 4 + 5, 2 == 2)
print(5 // 2)
print(5 % 2)
print(5 ** 2)"""

count = 0
count += 1

"""count /= 1
count %= 1
count **= 1
count -= 1"""
"""print(count)"""

flag1 = True # 1
flag2 = False # 0
# сравнение
"""
>
<
>=
<=
!=
== равно

and *
or +
not

is является
in проверка вхождения
"""

"""a = 5 > 2
b = 7 * 8 == 51
c = 7 != 8
print(a, b, c)

d = False or False or 5 > 2 
e = not True or True or False and 7 != 8
print(d, e)
f = True and False or True and False and True or 5 > 2
#    1    *   0    +    1   *    0    *   1
print(f)
print(flag1 is True)"""

"""if flag2:
    print("true")
elif flag1:
    print("2 true")
else:
    print("false")"""

"""
c = 0  # Ложь
e = ''  # ложь
f = [] # ложь
g = () # ложь
a = None  # ложь

d = "Hello"  # Истина

if a:
    print("true")
else:
    print("false")
"""
"""
day = 2
match day:
    case 1: print("Monday")
    case 2: print("Tuesday")
    case 3: print("Wednesday")
    case 4: print("Thursday")
    case 5: print("Friday")
    case 6: print("Saturday")
    case 7: print("Sunday")
    case _: print("Invalid day")"""
"""
count = 0
while count < 10:
    print(count)
    count += 1
    if count == 8:
        break
    if count == 5:
        count += 1
        continue
else:
    print("Loop finished")"""

# для элементов в последовательности
"""str1 = '123456'
for c in str1:
    print(c)"""

# списки
"""
list
[]
"""

"""list1 = [1, 2, 3, 4, 5]

zero_list = []
zero_list = list()

for e in list1:
    print(e)"""

"""for i in range(5):
    print(i)

print(range(5))
print(list(range(5)))"""
"""
(конец)
(начало, конец)
(начало, конец (не включительно), шаг)
"""
"""print(list(range(50, 5, 4)))"""

"""for _ in range(5):
    print("Hello")
else:
    print("Loop finished")
"""

zapr = "$%^&*"
login = "myLogin"

for c in login:
    if c in zapr:
        print("вы ввели логин с запрещенными символами")
        break
else:
    print("вы ввели безопасный логин")

#isinstance

str1: str = '213'

def add(a: int, b: int) -> int:
    return a + b

print(add("1", "2"))
str1 = '123'
#все методы строк без кода
"""
.join() - объединяет элементы итерируемого объекта в одну строку
.strip() - удаляет пробельные символы в начале и в конце
.count() - подсчитывает количество вхождений подстроки
.find() - находит индекс первого вхождения подстроки
.replace() - заменяет одну подстроку на другую
.split() - разбивает строку на список подстрок по указанному разделителю

.capitalize() - перевод первого символа строки в верхний регистр
.lower() - преобразует все символы строки в нижний регистр
.upper() - преобразует все символы строки в верхний регистр
.title() - преобразует первую букву каждого слова в верхний регистр
.swapcase() - меняет регистр всех символов на противоположный

.center() - центрирует строку, дополняя ее пробелами
.ljust() - выравнивает строку по левому краю, дополняя ее пробелами справа
.rjust() - выравнивает строку по правому краю, дополняя ее пробелами слева
.zfill() - дополняет строку нулями слева до указанной длины

.rfind() - находит индекс последнего вхождения подстроки
.index() - находит индекс первого вхождения подстроки (вызывает ValueError, если не найдено)
.rindex() - находит индекс последнего вхождения подстроки (вызывает ValueError, если не найдено)
.startswith() - проверяет, начинается ли строка с указанной подстроки
.endswith() - проверяет, заканчивается ли строка указанной подстрокой
.rsplit() - разбивает строку на список подстрок по указанному разделителю, начиная с правого края
.partition() - разбивает строку на три части по первому вхождению разделителя
.rpartition() - разбивает строку на три части по последнему вхождению разделителя

.isalnum() - проверяет, состоит ли строка только из букв и цифр
.isalpha() - проверяет, состоит ли строка только из букв
.isdigit() - проверяет, состоит ли строка только из цифр
.islower() - проверяет, состоит ли строка только из символов в нижнем регистре
.isupper() - проверяет, состоит ли строка только из символов в верхнем регистре
.istitle() - проверяет, начинается ли каждое слово в строке с заглавной буквы
.isspace() - проверяет, состоит ли строка только из пробельных символов
"""
#.join() - объединяет элементы итерируемого объекта в одну строку. Пример:
words = ['Hello', 'world', '!']
result = ' '.join(words)
print(result)  # Output: Hello world !

#.strip() - удаляет пробельные символы в начале и в конце. Пример:
text = '   Hello, World!   '
stripped_text = text.strip()
print(stripped_text)  # Output: Hello, World!

#.count() - подсчитывает количество вхождений подстроки. Пример:
sentence = 'The quick brown fox jumps over the lazy dog'
count = sentence.count('the')
print(count)  # Output: 1

#.find() - находит индекс первого вхождения подстроки. Пример:
text = 'Python is awesome'
index = text.find('is')
print(index)  # Output: 7

#.replace() - заменяет одну подстроку на другую. Пример:
original = 'Hello, World!'
modified = original.replace('World', 'Python')
print(modified)  # Output: Hello, Python!

#.split() - разбивает строку на список подстрок по указанному разделителю. Пример:
sentence = 'The quick brown fox'
words = sentence.split()
print(words)  # Output: ['The', 'quick', 'brown', 'fox']

def add(a, b):
    print(a + b)

def add(a, b):
    return a + b

def add():
    return "сумма"

"""def multy_return():
    return 1, 2, 3, 4"""

def multy_return(amount=0):
    if amount == 0:
        return None, None, None, None
    return 1, 2, 3, 4
a, b, c, d = multy_return()
print(a, b, c, d)

#списки
#все методы списков без кода
# Методы списков:
zero_list = []
zero_list += [1, 2]
"""
append() - добавляет элемент в конец списка
insert() - вставляет элемент в указанную позицию
remove() - удаляет первое вхождение указанного элемента
pop() - удаляет и возвращает элемент по индексу (по умолчанию последний)
index() - возвращает индекс первого вхождения элемента
count() - возвращает количество вхождений элемента

clear() - удаляет все элементы из списка
sort() - сортирует список на месте
copy() - возвращает поверхностную копию списка

reverse() - разворачивает список на месте
extend() - добавляет элементы из итерируемого объекта в конец списка

Функции для работы со списками:

sorted() - возвращает новый отсортированный список
reversed() - возвращает итератор в обратном порядке
list() - создает список из итерируемого объекта

any() - возвращает True, если хотя бы один элемент истинный
all() - возвращает True, если все элементы истинные

enumerate() - возвращает итератор пар (индекс, значение)
zip() - создает итератор кортежей, где i-й кортеж содержит i-й элемент из каждого переданного итерируемого объекта
"""

# append() - добавляет элемент в конец списка. Пример:
fruits = ['apple', 'banana']
fruits.append('cherry')
print(fruits)  # Output: ['apple', 'banana', 'cherry']

# insert() - вставляет элемент в указанную позицию. Пример:
numbers = [1, 2, 4]
numbers.insert(0, 3)
print(numbers)  # Output: [1, 2, 3, 4]

# remove() - удаляет первое вхождение указанного элемента. Пример:
animals = ['cat', 'dog', 'cat']
animals.remove('cat')
print(animals)  # Output: ['dog', 'cat']

# pop() - удаляет и возвращает элемент по индексу (по умолчанию последний). Пример:
colors = ['red', 'green', 'blue']
last_color = colors.pop()
print(last_color)  # Output: 'blue'
print(colors)  # Output: ['red', 'green']

# index() - возвращает индекс первого вхождения элемента. Пример:
letters = ['a', 'b', 'c', 'a']
index_of_a = letters.index('a')
print(index_of_a)  # Output: 0

# count() - возвращает количество вхождений элемента. Пример:
numbers = [1, 2, 3, 1, 1, 4]
count_of_ones = numbers.count(1)
print(count_of_ones)  # Output: 3


list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list1[1:6:2])
# начало, конец не включая, шаг
print(list1[::-1])

#Null nil None
"""
:b - двоичная форма
:с - преобразование в юникод
:d - десятичный
:о - восьмеричный
:х - шеснадцатеричный, нижний
:+ - отображает + только для положительных
:- - отображает - только для отрицательных
:(пробел) - дополнительный пробел перед положительными и отрицательными
:< - выравнивние по левому краю
:> - по правому краю
:^ - по центру

"""
some_number = 104
print(f'erfger {some_number} = {some_number:b} в двоичной')
print(f'erfger {some_number:c} ')
print(f'erfger {some_number:-} ')
print(f'erfger {some_number:+} ')
print(f'erfger {some_number: } ')
print(f'erfger {some_number:^} ')
print(f'erfger {some_number:<} ')
print(f'erfger {some_number:>} ')
print(f'erfger {some_number:.2f} ') #округление до двух знаков


def multy_return(amount=0, amount2=0, amount3=0):
    return

result = multy_return(10, amount3=10)


import math
import math as m
from math import pi
from math import pi, pow
from math import pi as p, pow

from math import *
print(pi)
print(m.pi)

from functions import add
add(1, 2)
import my_package
# python -m twine uploaad dist/*

from random import *

print(random()) # случайное от 0 до 1
print(randint(1, 10)) # случайное целое от а до б
list1 = [i * 8 for i in range(5)]
print(choice(list1)) # случайное из последовательности
print(choices(list1, k=2)) # несколько случайных из последовательности
shuffle(list1) # перемешать элементы
print(list1)
print(uniform(1.5, 5.6)) # случайное дробное от а до б
print(randrange(0, 100, 5))
print(sample(list1, k=2))


#управление состоянием генератора
seed(42) # фиксация случайных
#getstate() # возвращает текущее состояние генератора
#setstate(state) # устанавливает состояние генератора

"""print(random()) # случайное 0.0-1.0
print(randint(a, b)) # случайное [a-b]


print(randrange(a, b, c)) #случайное из диапазона
print(uniform(a, b)) #слуаное дробное [ab]
print(choice(squence)) #случайный элемент из последовательности
print(shuffle(squence)) # перемешивает последовательность на месте
print(sample(population, k)) # population - последовательность, k уникальных элементов
"""
#tuple - кортеж - неизменяемая последовательность

tuple1 = tuple([1, 2, 3, 4]) # приводит к неизменияемому типу данных
print(tuple1)
tup = (1, 2, 4, '123')
zero_tuple = tuple()
zero_tuple = ()
print(tup)
print(type(tup).__name__)
tup2 = ([], 1, 2, 4, '123')
print(tup)
tup2[0].append(1)
print(tup * 2)

print(tup[1:3])

print(tup + tup2)
print(2 in tup)
print(len(tup))
for i in tup:
    print(i)

#ссылки
"""
все передается по ссылке
"""
#изменяемые
"""
списки
словари
множества
"""
#неизменяемые - хешируемые - для создания ключа у словаря
"""
строки
кортежи
целые числа
дробные числа
логические значени
frozenset
"""
#weakref

a = [1, 2]
b = a
print(id(a), id(b))

b.append(3)
print(a, id(a))

s = 'hello'
t = s
print(id(s), id(t))

t = 'world'

print(s, t, id(s), id(t))
#id() - возвращает уникальный идентификатор

#hash() - возвращает хеш-значение 
a = '12'
b = [1]
print(hash(a))

# множества set
inp = [1, 1, 2, 2]

print(set(inp)) # делает множество уникальных значений

some_set = {1, 2, 3, 3}
print(some_set)
print(type({}))
print(type(set()))

zero2_set = set()
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3)
zero2_set.add(3) # добавление
print(zero2_set)
zero2_set.update(range(5))
print(zero2_set)
zero2_set.discard(1)
print(zero2_set)
zero2_set.remove(2)
print(zero2_set)
popped = zero2_set.pop()
print(zero2_set)
print(popped)
zero2_set.clear()
print(zero2_set)
union_set = {1, 2, 3}.union({13, 2})
union2_set = {1, 2, 3} | {13, 2}
print(union_set)
"""
.set() пустое
.set(iterable) итерируемый объект в множество
.add(element) добавление
.remove(element) удаляет с ошибкой если отсутствует
.pop() удаляет случайный без ошибки
.discard(element) удаляет без ошибки
.copy() копия 
.clear() удаляет полностью

.update(other) |= добавление элементов ищ другого множества
.intersection_update(other) &=  оставляет в множестве только общие элементы с другим множеством
.symmetric_difference_update(other) ^= есть в одном из множеств но не в обоих одновременно
.union(other) | объединение 
.intersection(other) & только общие элементы для обоих множеств
.difference(other) - есть в первом но нет во втором
.difference_update(other) ^ -= симметричная разность. Есть только в одном из множеств но не в обеих одновременно

.isdisjoint(other) True, если set и other не имеют общих элементов
.issubset(other) <= True если все эл set принадлежат other
.issuperset(other) >= True если все из other принадлежат set
"""

intersection_set = {1, 2, 3}.intersection({13, 2})
intersection2_set = {1, 2, 3} & {13, 2}
print(intersection_set)
difference_set = {1, 2, 3}.difference_update({3, 4, 5})
difference2_set = {1, 2, 3} - {3, 4, 5}

print(difference_set)
print(difference2_set)

fs1 = frozenset([1, 2, 3])
fs2 = frozenset([3, 4, 5])

"""
frozenset() пустое
frozenset(iterable) итерируемый объект в неизменяемое множество

copy

union
intersection
difference
symmetric_difference
isdisjoint
issubset
issuperset

"""
print(fs1 | fs2)
print(fs1 & fs2)
print(fs1 - fs2)
print(fs1 ^ fs2)
print(fs1 <= fs2)
print(fs1 >= fs2)

d = {
    frozenset([1, 2, 3]): "value1",
    frozenset([4, 5, 6]): "value2",
}